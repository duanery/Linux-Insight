# 框架分析方法

> [![40](https://github.com/duanery/picture/blob/master/github/github_black_40px.png)](https://duanery.github.io)
> &nbsp;&nbsp;
> ***duanery*** &nbsp;
> 2019年5月18日
>
> Linux爱好者

在读源码时，一般会采用深度优先的思路，不断的进入到每一个函数中，来理解函数的意图。这样基本可以把函数调用过程梳理清楚。函数调用的先后顺序，函数调用链，都是揭示代码逻辑的重心。但Linux内核中充斥着很多的回调函数，又可能会把回调函数聚集到一起形成一个数据结构，在分析函数调用链时，总会碰到回调函数的调用，这时候就会卡壳，不知道回调函数具体赋了什么值。这该怎么分析？

一般用到回调函数时，都意味着存在一个或大或小的框架。可以认为框架是不变的，是在各类条件下都相同的部分。而回调函数是变化的部分，在不同的条件下回调函数会被赋予不同的值。

那么框架分析就是指分析这个相同的部分和不同的部分的临界点。分析相同的部分和各个不同部分的内部逻辑，一般都可以采用面向过程的分析思路。但分析临界点，则需要面向对象的分析方法，需要更高的技巧，更灵活的思路。

假设已经搞清楚相同的部分和不同的部分的临界点，那么就可以把不同的部分抽象成一个基类，各个不同的部分都派生于基类，提供各自的实现。只是c语言没有实现类，所以派生关系不是那么直观，导致在真正的分析过程中，很少会有人能做到以面向对象的方式来看待回调函数。而且也没有办法根据回调函数很直观的看到各个派生的类的意图。

框架的分析就是指，如何把回调函数转换为基类，并找出所有的派生类，最终再反推以去掉面向对象的思想来优化分析过程(加速分析)。

有些源码，虽然没提供回调函数的明确实现，但是确蕴含着一些回调函数的想法。如，对不同的部分提供了多种实现，但是通过编译选项来控制具体选择哪个实现，在编译时就把回调函数唯一化了。

框架分析，就是以不变应万变。

## 1. 意识到框架的存在

在面向过程的分析流中，如果遇到了回调函数的调用，即暗示着框架的存在。回调函数所在的结构体(后文以S来称呼这个结构体)，可以被当成一个基类来看待。以S来定义一个变量(后文以A来称呼这个变量)，这个变量就可以被看成是一个对象。

具体的：

1. 如果S中只有回调函数，没有任何其他的变量。

2. 变量A可以被定义为全局变量，因此回调函数必须是在编译时赋值的。变量A中的回调函数一旦赋值，意味着派生类的诞生，派生于基类，并提供了基类的一种实现。

   变量A的定义即暗示着变量A做为一个派生类而被实现。

   ```c
   //S.h
   struct S {
   	void (*func)();
   };
   
   //A.c
   void A_func()
   {
       ...
   }
   struct S A = {
       .func = A_func;
   };
   A.func(); //调用回调
   ```

   ```cpp
   //S.h
   class S {
   public:
       virtual void func();
   };
   
   //A.h
   class A : public S {
       void func() {
           ...
       }
   };
   class A A;
   A.func(); //模拟调用回调
   ```

   如上述例子所示，分析时需要把A_func作为派生类的实现来看待。

   可以把变量A看做是派生类的类名。同时又是派生类定义的一个对象的对象名。

3. 变量A在程序运行时被动态分配，那么回调函数也必须是在运行时赋值的。那么派生类意味着在代码运行时诞生的。

4. 变量A的地址在程序运行时被赋值给其他变量。如`B->ops = &A`。这意味着再次派生。

## 2. 框架的表示方法

呈现框架各个回调函数的调用点。就可以呈现出回调函数的外部环境。
