# 内核分析基础

> [![40](https://github.com/duanery/picture/blob/master/github/github_black_40px.png)](https://duanery.github.io)
> &nbsp;&nbsp;
> ***duanery*** &nbsp;
> 2019年7月20日
>
> Linux爱好者

描述内核分析的基础认知。

## 一、编译相关

### 编译内核源码由Kbuild定义的宏

#### 编译.c文件
- \_\_KERNEL__: 内核编译，内核头文件可以用于用户态的应用程序来include，也可以用于内核源码，内核源码在编译时会指定该宏。
- KBUILD_BASENAME: basename，编译源码文件去掉后缀，且-替换为_得到的名字
- KBUILD_MODNAME: 模块名字，一般等于basename

#### 编译.s文件
- \_\_KERNEL\_\_: 内核编译，汇编文件也会包含内核头文件，也需要区分是内核include，还是用户态include。
- \_\__ASSEMBLY\_\_: 指定正在编译汇编代码。内核头文件中，可能会区分在汇编模式下某些宏的定义，跟非汇编模式下该宏的定义不一致。

### 编译模块由Kbuild定义的宏
#### 编译.c文件
- \_\_KERNEL\_\_: 同上
- KBUILD_BASENAME: 同上
- KBUILD_MODNAME: 同上
- MODULE: 编译模块，obj-m指定的需要编译为模块的文件，在编译时会加上MODULE宏。

#### 编译.s文件
- \_\_KERNEL\_\_:  同上
- \_\__ASSEMBLY\_\_: 同上
- MODULE: 同上

## 二、基本意识
- 数据结构是内嵌式的还是独立式的。

  对于内核的各个结构体，要有意识的区分结构体是内嵌式的，还是独立式的。许多结构体就是最终的结构体，不再内嵌到其他结构体内部，完全独立使用，但可能会在其他结构体中提供指针。 也有一部分结构体完全是内嵌式的，大多数情况都会被内嵌到其他结构体内部而不会独立使用。 还有可能有2种情况都有，既可以内嵌，也可以独立使用。  要有这种看待一个结构体的意识，才能看懂代码的某些实现，需要外部配合。

- 数据结构是全局的，还是percpu的。

  内核有部分数据结构是percpu的，操作这些数据结构一般都比较隐蔽，而且是操作当前cpu的数据结构，稍微不注意就不知道数据结构的根在哪了。
  
- \_\_xxxx()函数和xxxx()函数之间的关系。

  会有多种关系：
  1. 无锁版和有锁版。\_\_xxxx()函数是无锁的，xxxx()函数是有锁的。
  2. 基础实现和完整实现。\_\_xxxx()函数是基础实现，实现内部功能。xxxx()函数会加上一些外部条件判断再调用\_\_xxxx()函数，一般定义为内联函数。
  3. 丰富参数版和简化参数版。\_\_xxxx()函数是参数比较齐全的。xxxx()函数则把参数设定为固定值，简化参数。
  4. 单cpu和percpu版本。\_\_xxxx()函数是单个cpu执行的。xxxx()函数则为每个cpu实现，一般会遍历每个cpu。
  5. 2个函数基本含义相同，但有一些略微差异。所以加\_\_区分开。

## 三、感悟

- 内核的跨度

  很重要的功能，有时候却对应着较少的代码，会淹没在大量的内核代码中，初次阅读代码往往不容易发现。有时候分析内核往往需要先靠记忆记住一部分逻辑，然后再从更高的维度看这个功能，才能发现一些顶层设计，第一遍看代码往往只能发现基本逻辑，第二遍再看的时候第一遍记忆会模糊，又需要重新看一遍，然后才能发现一些隐藏的逻辑，要收集全所有顶层设计，往往跨度会比较大，这需要把中间分析过程形成文档，下次再分析源码可以以文档为基础，得到一些基础理解，再分析未发现的代码，逐次迭代可大成。